# 詳細設計

> 前提：JSON なし。daily 本文は自由（長文 OK）。機械が読むのは `## INDEX` のみ。  
> 何日サボっても `etl --full` と `build_index` 一発で最新に収束する（冪等）。

---

## 0. 用語・前提

### 用語

- **Vault**：Obsidian で開くルートフォルダ（Markdown 保管庫）
- **Daily**：`daily/YYYY-MM-DD.md` の日次ノート
- **INDEX**：Daily 内の「機械が読む固定文法セクション」
- **Block ID**：Obsidian ブロック参照用の `^20251213-t1` など
- **DB**：SQLite（索引用）
- **Index Notes**：`index/*.md` の自動生成ノート（一覧・導線）

### 想定 OS/実行環境

- macOS
- Python 3.11+（推奨）
- VS Code 上で実行（タスク化）
- Obsidian は閲覧・探索用途

### 実装ステップとの対応（手順書で詳細化予定）

- Step1: DB 初期化（`init_db.sql`）と `taxonomy/tags.yml` の雛形作成
- Step2: サンプル daily をテンプレから生成
- Step3: `python scripts/etl.py --full`（全走査 Upsert）
- Step4: `python scripts/build_index.py`（index 再生成）
- Step5: `python scripts/export_pack.py` で抽出パック生成
- Step6: `python scripts/validate_daily.py` で規約チェック
- Step7: 週次タグ棚卸し（tags.yml 更新→ `etl --full`）

---

## 1. フォルダ/ファイル設計（確定）

```
vault/
  daily/
    YYYY-MM-DD.md
  index/
    ideas.md
    actions.md
    books/
      <bookname>.md
    tags/
      <tag>.md               # 任意（必要になったら）
  exports/
    <generated>.md
  drafts/
    <generated>.md
  taxonomy/
    tags.yml
  db/
    notes.sqlite
  scripts/
    etl.py
    build_index.py
    export_pack.py
    validate_daily.py        # 任意
  docs/
    ai-instructions.md
```

---

## 2. Daily ノート詳細仕様

### 2.1 セクション仕様（本文は自由、INDEX は固定）

Daily の必須要素：

- `## INDEX` セクション（必須）
- INDEX 内の行（0 件でも OK。ただし運用上は 1 件以上推奨）
- 各 INDEX 行末尾の `^block-id`（必須）

推奨（任意要素）：

- `Key Takeaways (indexed)`（ブログ化核、3〜7 個）
- `RAW`（入力原文）

### 2.2 Block ID 命名規則（固定）

形式：`^YYYYMMDD-<kind><n>`

- `YYYYMMDD`：その Daily の日付
- `kind`（用途別に固定）
  - `t`：takeaway（本文中の核）
  - `l`：learning（索引用の学び項目）
  - `e`：experiment（索引用の試行）
  - `i`：idea（索引用のアイデア）
  - `a`：action（索引用のアクション）
- `n`：1 からの連番（同日内で重複しない）

例：

- `^20251213-t1` / `^20251213-l1` / `^20251213-a2`

> 重要：DB の一意キーに `source_path + block_id` を使うので、block_id の重複は NG。

---

## 3. INDEX 固定文法（最重要：機械契約）

### 3.1 INDEX セクション検出ルール

- 見出し行が `## INDEX` のセクションを対象とする
- セクション終了は次の `## ` 見出し出現、またはファイル末尾
- `## INDEX` が無い Daily は「フォーマット不正」として扱い、ETL はスキップ（ログに出す）

### 3.2 INDEX 行フォーマット（EBNF 風）

```
INDEX_LINE :=
  "- " "[" TYPE "]" " " BODY " " META? " " TAGS? " " BLOCK_ID

TYPE := "learning" | "experiment" | "idea" | "action"

BODY :=
  LINK_BODY | TEXT_BODY

LINK_BODY :=
  "![[daily/" DATE ".md#^" REF_BLOCK_ID "]]"

TEXT_BODY :=
  <任意の文字列（改行は不可）>

META := (actionのみ必須)
  "effort=" INT " " "status=" STATUS

STATUS := "inbox" | "doing" | "done" | "dropped"

TAGS :=
  ( "#"+ TAG )+

TAG :=
  PREFIX ":" VALUE

PREFIX :=
  "book" | "tech" | "topic" | "src" | "new" | "tmp"

VALUE :=
  <空白を含まない文字列>  ※書籍名などに空白を許容したい場合は後述の対策を採用

BLOCK_ID :=
  "^" YYYYMMDD "-" KIND INT
KIND := "t" | "l" | "e" | "i" | "a"
```

### 3.3 INDEX 行の具体例（推奨）

学びは文脈へ戻るため「takeaway ブロック参照」を貼る：

- `- [learning] ![[daily/2025-12-13.md#^20251213-t1]] #book:開発生産性の教科書 #topic:reading ^20251213-l1`

アイデアは短いラベルでも良い：

- `- [idea] メトリクスの週次レビューを自動化する #topic:workflow ^20251213-i1`

アクションは本文直書き＋メタ必須：

- `- [action] 週次で指標を1つ決める effort=30 status=inbox #topic:productivity ^20251213-a1`

### 3.4 書籍名に空白がある問題（設計としての扱い）

タグ値に空白が入るとパースが難しくなるため、どちらかに統一する：

A 案（推奨：簡単＆安定）

- タグ値は空白禁止にし、空白を `_` に置換する
  - `#book:開発生産性の教科書` → `#book:開発生産性の教科書`（空白が無いので OK）
  - もし英書名などで空白が出るなら `#book:The_Pragmatic_Programmer`

B 案（許容：少し複雑）

- タグ値を引用符で囲むルールを追加
  - `#book:"The Pragmatic Programmer"`
- 実装が少し難しくなるので、最初は A 案推奨

> 本設計では **A 案**を採用（空白は `_` に寄せる）として進める。

---

## 4. タグ辞書（taxonomy/tags.yml）詳細仕様

### 4.1 tags.yml スキーマ

```
approved:
  book: [ ... ]
  tech: [ ... ]
  topic: [ ... ]
  src: [ ... ]
rules:
  allow_new_prefix: ["new", "tmp"]
aliases:
  pw: tech:playwright
  bq: tech:bigquery
  prod: topic:productivity
```

### 4.2 タグ正規化ルール（ETL 側で保証）

入力（INDEX 行の `#...`）を以下で正規化して DB に入れる：

1. `#<alias>` 形式なら aliases を引く（例：`#pw` → `tech:playwright`）
2. `#prefix:value` 形式なら prefix/value を抽出
3. `approved` に存在するならそのまま採用
4. 存在しないなら
   - prefix が `new/tmp` なら許可
   - それ以外なら `new:<original>` に変換して保存（揺れを“new”に集約）

> こうすると「AI 出力が多少ブレても DB 側は収束」する。

---

## 5. DB 設計（SQLite）

### 5.1 テーブル一覧

- `items`：索引の本体
- `tags`：タグ辞書（DB 側）
- `item_tags`：多対多関連
- `etl_runs`（任意）：実行ログ（いつ ETL したか、件数、エラー数）

### 5.2 items（DDL）

キー設計：キャッチアップの核は **UNIQUE(source_path, block_id)**

```
items(
  id                INTEGER PK,
  date              TEXT NOT NULL,         -- YYYY-MM-DD
  type              TEXT NOT NULL,         -- learning/experiment/idea/action
  text              TEXT NOT NULL,         -- 短いラベル（またはリンク文字列）
  ref_source_path   TEXT,                  -- LINK_BODYが参照する daily/...
  ref_block_id      TEXT,                  -- LINK_BODYが参照する ^...
  source_path       TEXT NOT NULL,         -- daily/YYYY-MM-DD.md
  block_id          TEXT NOT NULL,         -- ^YYYYMMDD-...
  effort_min        INTEGER,               -- actionのみ
  status            TEXT,                  -- actionのみ
  content_hash      TEXT NOT NULL,         -- 変更検知（任意だが推奨）
  created_at        TEXT NOT NULL,
  updated_at        TEXT NOT NULL,
  UNIQUE(source_path, block_id)
)
```

#### 補足：ref_source_path/ref_block_id の狙い

- `learning` が `![[...#^...]]` を持つ場合、DB から exports を作る時に「参照先」を使って文脈を拾いやすい
- 無い場合は NULL で OK

### 5.3 tags / item_tags（DDL）

```
tags(
  id INTEGER PK,
  name TEXT NOT NULL UNIQUE   -- "tech:playwright" など
)

item_tags(
  item_id INTEGER NOT NULL,
  tag_id  INTEGER NOT NULL,
  PRIMARY KEY (item_id, tag_id),
  FOREIGN KEY (item_id) REFERENCES items(id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id)  REFERENCES tags(id)  ON DELETE CASCADE
)
```

#### マイグレーション方針（DDL 変更時）

- `init_db.sql` に最新のスキーマを保持し、ALTER スクリプトは別途保存する
- 変更が軽微な場合でも `UNIQUE(source_path, block_id)` を壊さないことを最優先
- 破壊的変更が必要な場合は `notes.sqlite` をバックアップし、`etl.py --full` で再構築できるかを事前に検証する

### 5.4 推奨インデックス

- `items(date)`, `items(type)`, `items(status)`（action 抽出用）
- `tags(name)` は UNIQUE で OK

---

## 6. スクリプト詳細設計

## 6.1 scripts/etl.py（daily -> DB）

### 6.1.1 目的

- daily 全件（または差分）を走査し `## INDEX` 行を抽出
- パースして `items/tags/item_tags` に **冪等 Upsert**
- 何日サボっても 1 回で最新へ収束

### 6.1.2 入力/出力

- 入力：`vault/daily/*.md`
- 出力：`vault/db/notes.sqlite`
- 参照：`vault/taxonomy/tags.yml`

### 6.1.3 主要処理フロー（ステップ）

1. `daily/` から `*.md` を列挙（全走査）
2. ファイルごとに
   - `## INDEX` セクションを抽出
   - 各行を `INDEX_LINE` としてパース
   - `date` はファイル名 `YYYY-MM-DD` から取る（本文 YAML は見ない）
3. タグを正規化（aliases/new 運用）
4. `content_hash` を作る（例：type+text+sorted(tags)+meta の sha256）
5. DB に Upsert（UNIQUE(source_path, block_id)）
6. item_tags を同期
   - シンプル案：既存関連を削除して入れ直し（件数が少ないので OK）
7. 失敗行はログに出し、他行は処理継続
8. 最後に件数サマリ（処理ファイル数/追加/更新/スキップ/エラー）

### 6.1.4 Upsert 仕様（更新条件）

- 同一 `(source_path, block_id)` が存在する場合
  - `content_hash` が同じなら更新不要（updated_at だけ更新しない）
  - 違うなら UPDATE（text/tags/meta/ref を差し替え）

### 6.1.5 パース失敗の扱い

- 1 行失敗してもスクリプト全体は停止しない
- ログに以下を記録
  - file path
  - line content
  - error reason（type 不正、block_id 欠落、action の meta 欠落等）

### 6.1.6 CLI

- `python scripts/etl.py --vault /path/to/vault --full`
  - `--full`：全走査（基本はこれで OK）
- `python scripts/etl.py --since 30`
  - 直近 N 日ファイルだけ（高速化・任意）
- `python scripts/etl.py --dry-run`
  - DB には書かず件数だけ出す（任意）

---

## 6.2 scripts/build_index.py（DB -> index ノート）

### 6.2.1 目的

- DB から必要な一覧を取り出し、`index/*.md` を **毎回フル再生成**
- 生成物なので「消して作り直す」が正しい

### 6.2.2 出力ファイル（確定）

1. `index/ideas.md`
2. `index/actions.md`
3. `index/books/<bookname>.md`

（必要になったら）

- `index/tags/<tag>.md`

### 6.2.3 各索引ノートの仕様

#### ideas.md

- 対象：`type='idea'`
- 並び：`date DESC`（新しい順）
- 表示：原本へ飛べるブロック参照（必須）
  - `- 2025-12-13: ![[daily/2025-12-13.md#^20251213-i1]] #topic:workflow`

#### actions.md

- 対象：`type='action' AND status IN ('inbox','doing')`
- 並び：
  1. status（doing 優先）
  2. effort_min ASC
  3. date DESC
- 表示：
  - `- [inbox|30m] 2025-12-13: ![[daily/2025-12-13.md#^20251213-a1]] #topic:productivity`

#### books/<bookname>.md

- 対象：タグに `book:<bookname>` を含む items（learning/idea/experiment/action 全部でも OK。推奨は learning + takeaway 参照）
- 並び：`date ASC`（読書の時系列が追える）
- 表示：
  - `- 2025-12-01: ![[daily/2025-12-01.md#^20251201-t2]]`
  - `- 2025-12-13: ![[daily/2025-12-13.md#^20251213-t1]]`

### 6.2.4 アトミック書き込み（壊れない生成）

- 各出力は `*.tmp` に書く → 成功したら置換
- 生成途中で落ちても、次回実行で復旧

### 6.2.5 CLI

- `python scripts/build_index.py --vault /path/to/vault`
- `--only ideas|actions|books`（任意）

---

## 6.3 scripts/export_pack.py（DB -> exports）

### 6.3.1 目的

- ブログ化の入力素材（参照ブロックの束）を生成する
- Vault 全文を AI に投げずに、必要最小限で品質を上げる

### 6.3.2 抽出条件（最低限）

- `--tag "book:xxx"`（必須）
- 期間：`--from YYYY-MM-DD --to YYYY-MM-DD`（任意）
- type：`--type learning|idea|experiment|action|all`（任意）

### 6.3.3 exports のフォーマット（固定化）

- frontmatter（必須）：`title`, `filters`（tag/type/from/to）, `generated_at`, `source_count`
- Body セクション構成：
  - `## Source Blocks`：`![[daily/...#^...]]` を並べる（同一ブロックは重複除去）
    - 並び順：基本は `date ASC`。期間が広い場合は `--order desc` オプションで切り替え可能にする
  - `## Notes`：AI が統合メモを書く余白
- type 混在時の並べ方：`type` を見出しにせず、日付順のみで並べる（シンプルを優先）

### 6.3.4 CLI

- `python scripts/export_pack.py --tag "book:開発生産性の教科書" --from 2025-11-01 --to 2025-12-31 --type learning`

---

## 6.4 scripts/validate_daily.py（任意だが強く推奨）

### 6.4.1 目的

- AI が規約を破った Daily を早期に検出する
- ETL がスキップした理由を可視化し、直しやすくする

### 6.4.2 チェック項目（最低限）

- `## INDEX` が存在するか
- INDEX 行末尾に `^block-id` があるか
- action 行に `effort=` と `status=` があるか
- タグが `#prefix:value` 形式か
- block_id がファイル日付と一致しているか（YYYYMMDD）

### 6.4.3 CLI

- `python scripts/validate_daily.py --vault /path/to/vault --since 30`

---

## 7. AI 向け規約文書（docs/ai-instructions.md）詳細仕様

### 7.1 目的

- Copilot 等が日次生成・修正で規約を守るための“憲法”
- 新人もこれを読むだけでテンプレと文法を理解できる

### 7.2 含める内容（最低限）

1. Daily テンプレ（セクション構成）
2. Block ID 命名規則（kind 別、例つき）
3. INDEX 固定文法（OK 例/NG 例）
4. タグ規約（prefix、辞書、new 運用、空白対策）
5. 「機械が読むのは INDEX だけ」という原則
6. コードブロックは ```` を使う（あなたの運用ルール）

---

## 8. エラーハンドリング/ログ設計

### 8.1 ログ出力方針

- 標準出力：処理件数サマリ（files_scanned / inserted / updated / unchanged / failed）
- `logs/etl_errors.log`（JSON Lines）：パース失敗行の詳細（file, line, reason）
- 失敗行は `quarantine/<date>.md` に元行を退避し、後で修正できるようにする

### 8.2 ETL サマリ（例）

- files_scanned
- index_lines_total
- items_inserted / items_updated / items_unchanged
- lines_failed（ファイル別件数）

---

## 9. テスト方針/検証

- INDEX パーサの golden テスト（OK/NG 例を fixtures に追加）
- サンプル daily を使った ETL 回帰テスト（items/tags/item_tags の件数・内容差分を確認）
- `init_db.sql` 適用テスト（空 DB への適用と UNIQUE 制約確認）
- `validate_daily.py` の CLI テスト（違反ケースごとに exit code とメッセージを確認）
- export_pack のスナップショットテスト（frontmatter/並び順/重複除去の確認）

---

## 10. “何日サボっても OK”を成立させる設計上の要点（チェックリスト）

- [ ] items に `UNIQUE(source_path, block_id)` がある
- [ ] etl は全走査しても OK（遅ければ --since を用意）
- [ ] build_index は毎回フル再生成（tmp→ 置換）
- [ ] daily の本文は揺れても INDEX だけ取れれば OK
- [ ] validate で規約違反を検出できる

---

次は「実装」に入る前に、詳細設計のうち **INDEX のタグ値の空白ルール**だけは確定しておきたい。  
この設計では **空白は `_` に置換（A 案）**で進める前提にしてあるので、実装ではそのまま採用します。

準備できたら「実装」に進み、まずは Step 1 として

- `init_db.sql`（DB 作成）
- `tags.yml`（最小辞書）
- `ai-instructions.md`（テンプレ＋ OK/NG 例）
  から作って、次に `etl.py` を書く流れが一番迷いません。
